{"version":3,"file":"static/js/128.b60fc67d.chunk.js","mappings":"uLAgKA,MACA,EAD2B,IAnI3B,MAIUA,4BAAAA,CAA6BC,GACnC,OAAKA,EAEDA,EAAQC,WAAW,KACd,IAAMD,EAAQE,UAAU,GAE1BF,EALc,EAMvB,CAEQG,cAAAA,GACN,MAAMC,EAAQC,aAAaC,QAAQ,cAC7BC,EAAuB,CAC3B,eAAgB,oBAOlB,OAJIH,IACFG,EAAuB,cAAC,UAAAC,OAAaJ,IAGhCG,CACT,CAKA,+BAAME,CAA0BT,GAC9B,IAAKA,EACH,MAAM,IAAIU,MAAM,wBAIlB,MAAMN,EAAQC,aAAaC,QAAQ,cAEnC,KADwD,SAAtCK,CAAAA,SAAAA,aAAAA,WAAAA,kCAAAA,qBAAAA,EAAAA,qBAAAA,EAAAA,qBAAAA,EAAAA,cAAAA,GAAYC,yBACXR,EACjB,MAAM,IAAIM,MAAM,sFAGlB,IAEE,MAAMG,EAAaC,EAAAA,EAAOC,aAEpBC,QAAiBC,MAAM,GAADT,OAAIK,EAAU,0BAAAL,OAAyBR,GAAW,CAC5EkB,OAAQ,MACRX,QAASY,KAAKhB,mBAGhB,IAAKa,EAASI,GAAI,CAChB,MAAMC,QAAkBL,EAASM,OAEjC,MADAC,QAAQC,MAAM,kBAAmBH,GAC3B,IAAIX,MAAM,uBAADF,OAAwBQ,EAASS,QAClD,CAGA,aADwCT,EAASU,MAEnD,CAAE,MAAOF,GAEP,MADAD,QAAQC,MAAM,8BAA+BA,GACvCA,CACR,CACF,CAMAG,gBAAAA,CAAiBC,GACf,IAAKA,EAAa,OAAO,KAEzB,IAEE,MAAMC,EAAO,IAAIC,KAAKF,GACtB,GAAIG,MAAMF,EAAKG,WACb,OAAO,KAGT,MAAMC,EAAOJ,EAAKK,cACZC,EAAQC,OAAOP,EAAKQ,WAAa,GAAGC,SAAS,EAAG,KAChDC,EAAMH,OAAOP,EAAKW,WAAWF,SAAS,EAAG,KAC/C,MAAM,GAAN9B,OAAUyB,EAAI,KAAAzB,OAAI2B,EAAK,KAAA3B,OAAI+B,EAC7B,CAAE,MAAOf,GAEP,OADAD,QAAQC,MAAM,sBAAuBA,GAC9B,IACT,CACF,CAMAiB,WAAAA,CAAYC,EAAeC,GACzB,IAAKD,IAAUC,EAEb,OADApB,QAAQqB,IAAI,iDAADpC,OAAwCkC,EAAK,YAAAlC,OAAWmC,KAC5D,EAIT,MAAME,EAAK,IAAIf,KAAKY,GACdI,EAAK,IAAIhB,KAAKa,GAGpB,GAAIZ,MAAMc,EAAGb,WAEX,OADAT,QAAQC,MAAM,kCAADhB,OAA8BkC,KACpC,EAET,GAAIX,MAAMe,EAAGd,WAEX,OADAT,QAAQC,MAAM,kCAADhB,OAA8BmC,KACpC,EAGT,MAAMI,EAASF,EAAGb,UAAYc,EAAGd,UAEjC,OADAT,QAAQqB,IAAI,mCAADpC,OAA0BkC,EAAK,MAAAlC,OAAKqC,EAAGb,UAAS,QAAAxB,OAAOmC,EAAK,MAAAnC,OAAKsC,EAAGd,UAAS,QAAAxB,OAAOuC,IACxFA,CACT,CAMAC,wBAAAA,CAAyBC,GACvB,IAAKA,IAAwBA,EAAoBC,MAA4C,IAApCD,EAAoBC,KAAKC,OAChF,OAAO,KAGT,MAAMC,EAAmBH,EAAoBC,KAAK,GAClD,OAAO/B,KAAKQ,iBAAiByB,EAAiBC,YAChD,E","sources":["services/transactionService.ts"],"sourcesContent":["import { CONFIG } from '../config';\n\ninterface TransactionResponse {\n  draw: number;\n  recordsFiltered: number;\n  recordsTotal: number;\n  data: Transaction[];\n}\n\ninterface Transaction {\n  Id: string;\n  status: string;\n  createAt: string;\n  createBy: string;\n  order: string;\n  type: string;\n  paymentNote: string;\n  updateNote: string | null;\n  amount: number;\n  Card_id: string;\n  bankName: string;\n  cardNumber: string;\n  responeText: string;\n  invoice_date: string | null;\n  noty: string | null;\n  order_pending: boolean;\n  CreateAtStr: string;\n}\n\nclass TransactionService {\n  /**\n   * Chuy·ªÉn ƒë·ªïi Store ID t·ª´ d·∫°ng S04314 sang A04314 (b·ªè S, thay b·∫±ng A)\n   */\n  private convertStoreIdToCustomerCode(storeId: string): string {\n    if (!storeId) return '';\n    // N·∫øu b·∫Øt ƒë·∫ßu b·∫±ng S, thay b·∫±ng A\n    if (storeId.startsWith('S')) {\n      return 'A' + storeId.substring(1);\n    }\n    return storeId;\n  }\n\n  private getAuthHeaders(): HeadersInit {\n    const token = localStorage.getItem('auth_token');\n    const headers: HeadersInit = {\n      'Content-Type': 'application/json',\n    };\n    \n    if (token) {\n      headers['Authorization'] = `Bearer ${token}`;\n    }\n    \n    return headers;\n  }\n\n  /**\n   * G·ªçi API ƒë·ªÉ l·∫•y transaction theo Store Code qua backend proxy\n   */\n  async getTransactionByStoreCode(storeId: string): Promise<TransactionResponse | null> {\n    if (!storeId) {\n      throw new Error('Store ID is required');\n    }\n\n    // Ki·ªÉm tra authentication tr∆∞·ªõc khi g·ªçi API\n    const token = localStorage.getItem('auth_token');\n    const isDevMode = process.env.REACT_APP_BYPASS_AUTH === 'true';\n    if (!isDevMode && !token) {\n      throw new Error('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ truy c·∫≠p d·ªØ li·ªáu.');\n    }\n\n    try {\n      // G·ªçi API qua backend proxy ƒë·ªÉ tr√°nh v·∫•n ƒë·ªÅ CORS v√† cookie\n      const backendUrl = CONFIG.API_BASE_URL;\n      \n      const response = await fetch(`${backendUrl}/api/ims/transactions/${storeId}`, {\n        method: 'GET',\n        headers: this.getAuthHeaders(),\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('Response error:', errorText);\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data: TransactionResponse = await response.json();\n      return data;\n    } catch (error) {\n      console.error('Error fetching transaction:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Parse date string t·ª´ CreateAtStr (format: \"Oct 13, 2025 10:19 AM\")\n   * Chuy·ªÉn ƒë·ªïi sang YYYY-MM-DD\n   */\n  parseCreateAtStr(createAtStr: string): string | null {\n    if (!createAtStr) return null;\n    \n    try {\n      // Parse date string nh∆∞ \"Oct 13, 2025 10:19 AM\"\n      const date = new Date(createAtStr);\n      if (isNaN(date.getTime())) {\n        return null;\n      }\n      // Chuy·ªÉn ƒë·ªïi sang YYYY-MM-DD\n      const year = date.getFullYear();\n      const month = String(date.getMonth() + 1).padStart(2, '0');\n      const day = String(date.getDate()).padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    } catch (error) {\n      console.error('Error parsing date:', error);\n      return null;\n    }\n  }\n\n  /**\n   * So s√°nh hai date strings (YYYY-MM-DD)\n   * Tr·∫£ v·ªÅ true n·∫øu date1 m·ªõi h∆°n date2\n   */\n  isDateNewer(date1: string, date2: string): boolean {\n    if (!date1 || !date2) {\n      console.log(`  ‚ö†Ô∏è  Date comparison failed: date1=${date1}, date2=${date2}`);\n      return false;\n    }\n    \n    // Parse dates - handle different formats\n    const d1 = new Date(date1);\n    const d2 = new Date(date2);\n    \n    // If parsing failed, try alternative formats\n    if (isNaN(d1.getTime())) {\n      console.error(`  ‚ùå Invalid date1 format: ${date1}`);\n      return false;\n    }\n    if (isNaN(d2.getTime())) {\n      console.error(`  ‚ùå Invalid date2 format: ${date2}`);\n      return false;\n    }\n    \n    const result = d1.getTime() > d2.getTime();\n    console.log(`  üìä Date comparison: ${date1} (${d1.getTime()}) > ${date2} (${d2.getTime()}) = ${result}`);\n    return result;\n  }\n\n  /**\n   * L·∫•y CreateAtStr t·ª´ transaction ƒë·∫ßu ti√™n (n·∫øu c√≥)\n   * Tr·∫£ v·ªÅ date string YYYY-MM-DD ho·∫∑c null\n   */\n  getLatestTransactionDate(transactionResponse: TransactionResponse | null): string | null {\n    if (!transactionResponse || !transactionResponse.data || transactionResponse.data.length === 0) {\n      return null;\n    }\n    \n    const firstTransaction = transactionResponse.data[0];\n    return this.parseCreateAtStr(firstTransaction.CreateAtStr);\n  }\n}\n\nconst transactionService = new TransactionService();\nexport default transactionService;\n\n"],"names":["convertStoreIdToCustomerCode","storeId","startsWith","substring","getAuthHeaders","token","localStorage","getItem","headers","concat","getTransactionByStoreCode","Error","process","REACT_APP_BYPASS_AUTH","backendUrl","CONFIG","API_BASE_URL","response","fetch","method","this","ok","errorText","text","console","error","status","json","parseCreateAtStr","createAtStr","date","Date","isNaN","getTime","year","getFullYear","month","String","getMonth","padStart","day","getDate","isDateNewer","date1","date2","log","d1","d2","result","getLatestTransactionDate","transactionResponse","data","length","firstTransaction","CreateAtStr"],"sourceRoot":""}